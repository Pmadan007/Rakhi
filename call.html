<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Rakhi Video Call</title>

  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f2f2f2;
    }

    h1 {
      margin-top: 20px;
    }

    #loading {
      margin: 20px;
      padding: 20px;
      background: #fff3cd;
      border-radius: 5px;
      color: #856404;
    }

    #error {
      margin: 20px;
      padding: 20px;
      background: #f8d7da;
      border-radius: 5px;
      color: #721c24;
    }

    #status {
      margin: 10px;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }

    #controls {
      margin: 10px;
      display: flex;
      gap: 10px;
    }

    button {
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    #video-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }

    video {
      width: 300px;
      height: 200px;
      background: black;
      border-radius: 10px;
      object-fit: cover;
    }

    .peer-wrapper {
      position: relative;
      display: inline-block;
    }

    .peer-name {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
    }

    .audio-only {
      width: 300px;
      height: 200px;
      background: #333;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      flex-direction: column;
    }

    .debug-info {
      margin: 10px;
      padding: 10px;
      background: #e2e3e5;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      max-width: 800px;
      max-height: 200px;
      overflow-y: auto;
    }

    .fallback-notice {
      margin: 20px;
      padding: 20px;
      background: #d1ecf1;
      border-radius: 5px;
      color: #0c5460;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>üé• Raksha Bandhan Call</h1>
  
  <div id="loading">Loading video call...</div>
  <div id="error" style="display: none;"></div>
  <div id="debug" class="debug-info" style="display: none;"></div>
  <div id="status" style="display: none;"></div>
  <div id="controls" style="display: none;">
    <button id="toggleAudio" class="btn-primary">üé§ Toggle Audio</button>
    <button id="toggleVideo" class="btn-primary">üìπ Toggle Video</button>
    <button id="leaveRoom" class="btn-danger">üö™ Leave Room</button>
  </div>
  <div id="video-container"></div>

  <script>
    let currentStream = null;
    let isAudioMuted = false;
    let isVideoMuted = false;
    let hmsSDK = null;

    // Debug function
    function addDebugInfo(message) {
      const debugDiv = document.getElementById('debug');
      debugDiv.style.display = 'block';
      debugDiv.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}<br>`;
      debugDiv.scrollTop = debugDiv.scrollHeight;
      console.log(message);
    }

    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.style.display = 'block';
      errorDiv.innerHTML = `‚ùå ${message}`;
      addDebugInfo(`ERROR: ${message}`);
    }

    function updateStatus(message, bgColor, textColor) {
      const statusDiv = document.getElementById('status');
      statusDiv.style.display = 'block';
      statusDiv.innerHTML = message;
      statusDiv.style.background = bgColor;
      statusDiv.style.color = textColor;
    }

    // Try to load HMS SDK using module approach
    async function loadHMSSDK() {
      // Method 1: Try the new official CDN approach
      try {
        addDebugInfo('Trying method 1: Official HMS SDK via script tag');
        
        // Set up module loading environment
        window.global = window;
        window.process = { env: { NODE_ENV: 'production' } };
        
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/@100mslive/hms-video-store@latest/dist/hms-video-store.umd.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
          setTimeout(() => reject(new Error('Timeout')), 15000);
        });

        await new Promise(resolve => setTimeout(resolve, 2000));

        // Check for HMS objects
        if (window.HMSVideoStore) {
          addDebugInfo('‚úÖ Found HMSVideoStore!');
          hmsSDK = window.HMSVideoStore;
          return true;
        }

        addDebugInfo('‚ùå HMSVideoStore not found in method 1');
      } catch (error) {
        addDebugInfo(`‚ùå Method 1 failed: ${error.message}`);
      }

      // Method 2: Try ES module approach
      try {
        addDebugInfo('Trying method 2: ES Module approach');
        
        const moduleScript = document.createElement('script');
        moduleScript.type = 'module';
        moduleScript.innerHTML = `
          import { HMSReactiveStore } from 'https://unpkg.com/@100mslive/hms-video-store@latest/dist/index.js';
          window.HMSReactiveStore = HMSReactiveStore;
          window.hmsModuleLoaded = true;
        `;
        document.head.appendChild(moduleScript);

        // Wait for module to load
        for (let i = 0; i < 50; i++) {
          await new Promise(resolve => setTimeout(resolve, 200));
          if (window.hmsModuleLoaded && window.HMSReactiveStore) {
            addDebugInfo('‚úÖ HMS loaded via ES modules!');
            hmsSDK = window.HMSReactiveStore;
            return true;
          }
        }

        addDebugInfo('‚ùå ES module loading timeout');
      } catch (error) {
        addDebugInfo(`‚ùå Method 2 failed: ${error.message}`);
      }

      // Method 3: Try direct script with require simulation
      try {
        addDebugInfo('Trying method 3: Require simulation');
        
        // Create a fake require/module system
        window.module = { exports: {} };
        window.exports = window.module.exports;
        window.require = function(name) {
          addDebugInfo(`Mock require called for: ${name}`);
          return {};
        };

        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/@100mslive/hms-video-store@latest/dist/index.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
          setTimeout(() => reject(new Error('Timeout')), 15000);
        });

        await new Promise(resolve => setTimeout(resolve, 2000));

        if (window.module.exports && typeof window.module.exports === 'object') {
          addDebugInfo('‚úÖ Found exports in module.exports!');
          hmsSDK = window.module.exports;
          
          // Set up global access
          if (hmsSDK.HMSReactiveStore) {
            window.HMSReactiveStore = hmsSDK.HMSReactiveStore;
          } else if (hmsSDK.default) {
            window.HMSReactiveStore = hmsSDK.default;
          }
          
          return true;
        }

        addDebugInfo('‚ùå No valid exports found in method 3');
      } catch (error) {
        addDebugInfo(`‚ùå Method 3 failed: ${error.message}`);
      }

      // Method 4: Try the simple approach one more time with different timing
      try {
        addDebugInfo('Trying method 4: Simple approach with extended wait');
        
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://sdk.100ms.live/web/hms.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
          setTimeout(() => reject(new Error('Timeout')), 20000);
        });

        // Wait much longer
        await new Promise(resolve => setTimeout(resolve, 5000));

        // Check all possible global objects
        const possibleObjects = [
          'HMSReactiveStore', 'HMS', 'HMSVideoStore', 'HMSSDK', 
          'HMSStore', 'HMSActions', 'HMSNotifications', 'hms'
        ];

        for (const objName of possibleObjects) {
          if (window[objName]) {
            addDebugInfo(`‚úÖ Found ${objName} in method 4!`);
            hmsSDK = window[objName];
            return true;
          }
        }

        addDebugInfo('‚ùå No HMS objects found in method 4');
      } catch (error) {
        addDebugInfo(`‚ùå Method 4 failed: ${error.message}`);
      }

      return false;
    }

    // HMS-based implementation with flexible SDK access
    async function initializeHMSCall(roomId, role, authToken) {
      try {
        addDebugInfo('Initializing HMS call...');
        
        // Try to find HMS classes in the loaded SDK
        let HMSStore, HMSActions, HMSNotifications;
        
        // Check different possible structures
        if (window.HMSReactiveStore) {
          addDebugInfo('Using HMSReactiveStore structure');
          HMSStore = window.HMSReactiveStore.HMSStore;
          HMSActions = window.HMSReactiveStore.HMSActions;
          HMSNotifications = window.HMSReactiveStore.HMSNotifications;
        } else if (hmsSDK && hmsSDK.HMSStore) {
          addDebugInfo('Using hmsSDK structure');
          HMSStore = hmsSDK.HMSStore;
          HMSActions = hmsSDK.HMSActions;
          HMSNotifications = hmsSDK.HMSNotifications;
        } else if (hmsSDK && hmsSDK.default) {
          addDebugInfo('Using hmsSDK.default structure');
          const sdk = hmsSDK.default;
          HMSStore = sdk.HMSStore;
          HMSActions = sdk.HMSActions;
          HMSNotifications = sdk.HMSNotifications;
        }

        if (!HMSStore || !HMSActions) {
          // List what we do have
          const available = [];
          if (hmsSDK) {
            available.push(...Object.keys(hmsSDK));
          }
          addDebugInfo(`Available in hmsSDK: ${available.join(', ')}`);
          throw new Error('HMS classes not found in any expected structure');
        }

        addDebugInfo('‚úÖ HMS classes found, creating store...');

        const hmsStore = new HMSStore();
        const hmsActions = new HMSActions(hmsStore);
        const hmsNotifications = HMSNotifications ? new HMSNotifications(hmsStore) : null;

        addDebugInfo('‚úÖ HMS objects created successfully');

        // Set up notifications if available
        if (hmsNotifications) {
          hmsNotifications.onNotification((notification) => {
            addDebugInfo(`HMS Notification: ${notification.type}`);
            if (notification.type === 'ERROR') {
              showError(`HMS Error: ${notification.data.message}`);
            }
          });
        }

        // Subscribe to store changes
        hmsStore.subscribe((store) => {
          addDebugInfo(`Store update: connected=${store.isConnected}, peers=${Object.keys(store.peers || {}).length}`);
          
          if (store.isConnected) {
            updateStatus(`‚úÖ Connected as ${store.localPeer?.name} | Peers: ${Object.keys(store.peers || {}).length}`, '#d4edda', '#155724');
            document.getElementById('controls').style.display = 'flex';
          } else {
            updateStatus(`üîÑ ${store.connectionState || 'Connecting'}...`, '#fff3cd', '#856404');
          }

          updateVideoContainer(store, hmsActions);
        });

        // Join room
        addDebugInfo('Attempting to join room...');
        await hmsActions.join({
          userName: role === "sister" ? "Sister" : "Brother",
          authToken: authToken,
          settings: {
            isAudioMuted: false,
            isVideoMuted: false,
          },
        });

        addDebugInfo('‚úÖ Join request sent successfully');
        setupHMSControls(hmsActions);

      } catch (error) {
        addDebugInfo(`‚ùå HMS call failed: ${error.message}`);
        throw error;
      }
    }

    function updateVideoContainer(store, hmsActions) {
      const container = document.getElementById('video-container');
      container.innerHTML = '';

      if (!store.peers) return;

      Object.values(store.peers).forEach(peer => {
        if (peer.videoTrack && store.tracks) {
          const videoTrack = store.tracks[peer.videoTrack];
          if (videoTrack && videoTrack.enabled) {
            const wrapper = document.createElement('div');
            wrapper.className = 'peer-wrapper';
            
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsInline = true;
            video.muted = peer.isLocal;
            
            const nameLabel = document.createElement('div');
            nameLabel.className = 'peer-name';
            nameLabel.textContent = peer.name + (peer.isLocal ? ' (You)' : '');
            
            wrapper.appendChild(video);
            wrapper.appendChild(nameLabel);
            container.appendChild(wrapper);
            
            hmsActions.attachVideo(videoTrack.id, video);
          }
        } else if (peer.audioTrack && store.tracks) {
          const audioTrack = store.tracks[peer.audioTrack];
          if (audioTrack && audioTrack.enabled) {
            const audioDiv = document.createElement('div');
            audioDiv.className = 'audio-only';
            audioDiv.innerHTML = `
              <div style="font-size: 48px;">üé§</div>
              <div style="margin-top: 10px;">${peer.name}${peer.isLocal ? ' (You)' : ''}</div>
            `;
            container.appendChild(audioDiv);
          }
        }
      });
    }

    function setupHMSControls(hmsActions) {
      document.getElementById('toggleAudio').onclick = async () => {
        try {
          await hmsActions.setLocalAudioEnabled(isAudioMuted);
          isAudioMuted = !isAudioMuted;
        } catch (error) {
          addDebugInfo(`Failed to toggle audio: ${error.message}`);
        }
      };

      document.getElementById('toggleVideo').onclick = async () => {
        try {
          await hmsActions.setLocalVideoEnabled(isVideoMuted);
          isVideoMuted = !isVideoMuted;
        } catch (error) {
          addDebugInfo(`Failed to toggle video: ${error.message}`);
        }
      };

      document.getElementById('leaveRoom').onclick = async () => {
        try {
          await hmsActions.leave();
          document.getElementById('video-container').innerHTML = '';
          document.getElementById('controls').style.display = 'none';
          updateStatus('üëã Left the room', '#d1ecf1', '#0c5460');
        } catch (error) {
          addDebugInfo(`Failed to leave room: ${error.message}`);
        }
      };
    }

    // Fallback WebRTC implementation
    async function initializeFallbackCall(roomId, role) {
      addDebugInfo('Using fallback WebRTC implementation');
      
      const container = document.getElementById('video-container');
      document.getElementById('controls').style.display = 'flex';
      
      const notice = document.createElement('div');
      notice.className = 'fallback-notice';
      notice.innerHTML = `
        <strong>üìπ Local Camera Mode</strong><br>
        HMS SDK couldn't load properly, showing your local camera only.<br>
        Share this URL with others: <code>${window.location.href}</code>
      `;
      document.body.insertBefore(notice, container);

      try {
        currentStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });

        const wrapper = document.createElement('div');
        wrapper.className = 'peer-wrapper';
        
        const video = document.createElement('video');
        video.srcObject = currentStream;
        video.autoplay = true;
        video.playsInline = true;
        video.muted = true;
        
        const nameLabel = document.createElement('div');
        nameLabel.className = 'peer-name';
        nameLabel.textContent = `${role === 'sister' ? 'Sister' : 'Brother'} (You)`;
        
        wrapper.appendChild(video);
        wrapper.appendChild(nameLabel);
        container.appendChild(wrapper);

        updateStatus('‚úÖ Local camera connected (Fallback mode)', '#d4edda', '#155724');

        // Fallback controls
        document.getElementById('toggleAudio').onclick = () => {
          const audioTracks = currentStream.getAudioTracks();
          audioTracks.forEach(track => {
            track.enabled = !track.enabled;
            isAudioMuted = !track.enabled;
          });
          document.getElementById('toggleAudio').textContent = 
            isAudioMuted ? 'üîá Unmute Audio' : 'üé§ Mute Audio';
        };

        document.getElementById('toggleVideo').onclick = () => {
          const videoTracks = currentStream.getVideoTracks();
          videoTracks.forEach(track => {
            track.enabled = !track.enabled;
            isVideoMuted = !track.enabled;
          });
          document.getElementById('toggleVideo').textContent = 
            isVideoMuted ? 'üì∑ Enable Video' : 'üìπ Disable Video';
        };

        document.getElementById('leaveRoom').onclick = () => {
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
          }
          container.innerHTML = '';
          document.getElementById('controls').style.display = 'none';
          updateStatus('üëã Left the room', '#d1ecf1', '#0c5460');
        };

      } catch (error) {
        showError(`Camera access failed: ${error.message}`);
      }
    }

    // Main application logic
    async function initializeApp() {
      const loadingDiv = document.getElementById('loading');
      
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get("room");
        const role = urlParams.get("role") || "sister";

        if (!roomId) {
          throw new Error("No room ID provided in URL. Please add ?room=YOUR_ROOM_ID to the URL");
        }

        addDebugInfo(`Starting app: room=${roomId}, role=${role}`);

        const hmsLoaded = await loadHMSSDK();
        
        if (hmsLoaded) {
          addDebugInfo('Getting auth token for HMS...');
          const tokenUrl = `/.netlify/functions/getToken?roomId=${roomId}&role=${role}`;
          
          const tokenRes = await fetch(tokenUrl);
          const responseText = await tokenRes.text();
          
          if (!tokenRes.ok) {
            throw new Error(`Token fetch failed (${tokenRes.status}): ${responseText}`);
          }

          let tokenData;
          try {
            tokenData = JSON.parse(responseText);
          } catch (e) {
            throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}`);
          }
          
          if (!tokenData.token) {
            throw new Error("No token received from server");
          }

          addDebugInfo('‚úÖ Token received, initializing HMS call...');
          await initializeHMSCall(roomId, role, tokenData.token);
        } else {
          addDebugInfo('HMS SDK failed to load, using fallback...');
          await initializeFallbackCall(roomId, role);
        }

        loadingDiv.style.display = 'none';

      } catch (error) {
        addDebugInfo(`‚ùå Application error: ${error.message}`);
        showError(error.message);
        loadingDiv.style.display = 'none';
        
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const role = urlParams.get("role") || "sister";
          await initializeFallbackCall(urlParams.get("room"), role);
        } catch (fallbackError) {
          addDebugInfo(`‚ùå Fallback also failed: ${fallbackError.message}`);
        }
      }
    }

    document.addEventListener("DOMContentLoaded", initializeApp);
  </script>
</body>
  </html>
